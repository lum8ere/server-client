// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"backed-api-v2/libs/3_generated_models/model"
)

func newCommand(db *gorm.DB, opts ...gen.DOOption) command {
	_command := command{}

	_command.commandDo.UseDB(db, opts...)
	_command.commandDo.UseModel(&model.Command{})

	tableName := _command.commandDo.TableName()
	_command.ALL = field.NewAsterisk(tableName)
	_command.ID = field.NewString(tableName, "id")
	_command.DeviceID = field.NewString(tableName, "device_id")
	_command.CommandType = field.NewString(tableName, "command_type")
	_command.UserID = field.NewString(tableName, "user_id")
	_command.Status = field.NewString(tableName, "status")
	_command.CreatedAt = field.NewTime(tableName, "created_at")
	_command.ExecutedAt = field.NewTime(tableName, "executed_at")

	_command.fillFieldMap()

	return _command
}

type command struct {
	commandDo

	ALL         field.Asterisk
	ID          field.String
	DeviceID    field.String
	CommandType field.String
	UserID      field.String
	Status      field.String
	CreatedAt   field.Time
	ExecutedAt  field.Time

	fieldMap map[string]field.Expr
}

func (c command) Table(newTableName string) *command {
	c.commandDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c command) As(alias string) *command {
	c.commandDo.DO = *(c.commandDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *command) updateTableName(table string) *command {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewString(table, "id")
	c.DeviceID = field.NewString(table, "device_id")
	c.CommandType = field.NewString(table, "command_type")
	c.UserID = field.NewString(table, "user_id")
	c.Status = field.NewString(table, "status")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.ExecutedAt = field.NewTime(table, "executed_at")

	c.fillFieldMap()

	return c
}

func (c *command) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *command) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 7)
	c.fieldMap["id"] = c.ID
	c.fieldMap["device_id"] = c.DeviceID
	c.fieldMap["command_type"] = c.CommandType
	c.fieldMap["user_id"] = c.UserID
	c.fieldMap["status"] = c.Status
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["executed_at"] = c.ExecutedAt
}

func (c command) clone(db *gorm.DB) command {
	c.commandDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c command) replaceDB(db *gorm.DB) command {
	c.commandDo.ReplaceDB(db)
	return c
}

type commandDo struct{ gen.DO }

type ICommandDo interface {
	gen.SubQuery
	Debug() ICommandDo
	WithContext(ctx context.Context) ICommandDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICommandDo
	WriteDB() ICommandDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICommandDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICommandDo
	Not(conds ...gen.Condition) ICommandDo
	Or(conds ...gen.Condition) ICommandDo
	Select(conds ...field.Expr) ICommandDo
	Where(conds ...gen.Condition) ICommandDo
	Order(conds ...field.Expr) ICommandDo
	Distinct(cols ...field.Expr) ICommandDo
	Omit(cols ...field.Expr) ICommandDo
	Join(table schema.Tabler, on ...field.Expr) ICommandDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICommandDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICommandDo
	Group(cols ...field.Expr) ICommandDo
	Having(conds ...gen.Condition) ICommandDo
	Limit(limit int) ICommandDo
	Offset(offset int) ICommandDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICommandDo
	Unscoped() ICommandDo
	Create(values ...*model.Command) error
	CreateInBatches(values []*model.Command, batchSize int) error
	Save(values ...*model.Command) error
	First() (*model.Command, error)
	Take() (*model.Command, error)
	Last() (*model.Command, error)
	Find() ([]*model.Command, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Command, err error)
	FindInBatches(result *[]*model.Command, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Command) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICommandDo
	Assign(attrs ...field.AssignExpr) ICommandDo
	Joins(fields ...field.RelationField) ICommandDo
	Preload(fields ...field.RelationField) ICommandDo
	FirstOrInit() (*model.Command, error)
	FirstOrCreate() (*model.Command, error)
	FindByPage(offset int, limit int) (result []*model.Command, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICommandDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c commandDo) Debug() ICommandDo {
	return c.withDO(c.DO.Debug())
}

func (c commandDo) WithContext(ctx context.Context) ICommandDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c commandDo) ReadDB() ICommandDo {
	return c.Clauses(dbresolver.Read)
}

func (c commandDo) WriteDB() ICommandDo {
	return c.Clauses(dbresolver.Write)
}

func (c commandDo) Session(config *gorm.Session) ICommandDo {
	return c.withDO(c.DO.Session(config))
}

func (c commandDo) Clauses(conds ...clause.Expression) ICommandDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c commandDo) Returning(value interface{}, columns ...string) ICommandDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c commandDo) Not(conds ...gen.Condition) ICommandDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c commandDo) Or(conds ...gen.Condition) ICommandDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c commandDo) Select(conds ...field.Expr) ICommandDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c commandDo) Where(conds ...gen.Condition) ICommandDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c commandDo) Order(conds ...field.Expr) ICommandDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c commandDo) Distinct(cols ...field.Expr) ICommandDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c commandDo) Omit(cols ...field.Expr) ICommandDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c commandDo) Join(table schema.Tabler, on ...field.Expr) ICommandDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c commandDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICommandDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c commandDo) RightJoin(table schema.Tabler, on ...field.Expr) ICommandDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c commandDo) Group(cols ...field.Expr) ICommandDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c commandDo) Having(conds ...gen.Condition) ICommandDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c commandDo) Limit(limit int) ICommandDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c commandDo) Offset(offset int) ICommandDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c commandDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICommandDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c commandDo) Unscoped() ICommandDo {
	return c.withDO(c.DO.Unscoped())
}

func (c commandDo) Create(values ...*model.Command) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c commandDo) CreateInBatches(values []*model.Command, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c commandDo) Save(values ...*model.Command) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c commandDo) First() (*model.Command, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Command), nil
	}
}

func (c commandDo) Take() (*model.Command, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Command), nil
	}
}

func (c commandDo) Last() (*model.Command, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Command), nil
	}
}

func (c commandDo) Find() ([]*model.Command, error) {
	result, err := c.DO.Find()
	return result.([]*model.Command), err
}

func (c commandDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Command, err error) {
	buf := make([]*model.Command, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c commandDo) FindInBatches(result *[]*model.Command, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c commandDo) Attrs(attrs ...field.AssignExpr) ICommandDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c commandDo) Assign(attrs ...field.AssignExpr) ICommandDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c commandDo) Joins(fields ...field.RelationField) ICommandDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c commandDo) Preload(fields ...field.RelationField) ICommandDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c commandDo) FirstOrInit() (*model.Command, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Command), nil
	}
}

func (c commandDo) FirstOrCreate() (*model.Command, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Command), nil
	}
}

func (c commandDo) FindByPage(offset int, limit int) (result []*model.Command, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c commandDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c commandDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c commandDo) Delete(models ...*model.Command) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *commandDo) withDO(do gen.Dao) *commandDo {
	c.DO = *do.(*gen.DO)
	return c
}
